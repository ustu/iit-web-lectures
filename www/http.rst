*************
Протокол HTTP
*************

**HTTP** (HyperText Transfer Protocol — протокол передачи гипертекста) — символьно-ориентированный клиент-серверный протокол прикладного уровня без сохранения состояния, используемый сервисом World Wide Web.

Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier – уникальный идентификатор ресурса) в запросе клиента. Основными ресурсами являются хранящиеся на сервере файлы, но ими могут быть и другие логические (напр. каталог на сервере) или абстрактные объекты (напр. ISBN). Протокол HTTP позволяет указать способ представления (кодирования) одного и того же ресурса по различным параметрам: mime-типу, языку и т. д. Благодаря этой возможности клиент и веб-сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.

Структура протокола
===================

Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх частей (рис. 1), которые передаются в следующем порядке:

1. Стартовая строка (англ. Starting line) — определяет тип сообщения;
2. Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
3. Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

.. figure:: /_static/wireshark-http-response.png
    :align: center

    Рис. 1. Структура протокола HTTP (дамп пакета, полученный сниффером Wireshark)

Стартовая строка HTTP
=====================

Cтартовая строка является обязательным элементом, так как указывает на тип запроса/ответа, заголовки и тело сообщения могут отсутствовать.

Стартовые строки различаются для запроса и ответа. **Строка запроса** выглядит так:

    Метод URI HTTP/Версия протокола

Пример запроса:

    GET /web-programming/index.html HTTP/1.1

Стартовая **строка ответа** сервера имеет следующий формат:

    HTTP/Версия КодСостояния [Пояснение]

Например, на предыдущий наш запрос клиентом данной страницы сервер ответил строкой:

    HTTP/1.1 200 Ok

Методы протокола
~~~~~~~~~~~~~~~~

Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами (Табл. 1). Названия метода чувствительны к регистру.

Таблица 1. Методы протокола HTTP

.. raw:: html

    <style>
        table, th, td {
            border-collapse: collapse;
            border: 1px solid black;
        }
    </style>

    <table summary="методы HTTP">
    <tbody><tr><th>Метод</th><th>Краткое описание</th></tr>
    <tr><td><strong>OPTIONS</strong></td>
    <td><p>Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса.
    Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён. Сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.</p>
    <p>Для того чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку &mdash; «*». Запросы «OPTIONS * HTTP/1.1» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.</p>
    <p>Результат выполнения этого метода не кэшируется.</p></td></tr>
    <tr><td><strong>GET</strong></td>
    <td><p>Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.
    Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:
    GET /path/resource?param1=value1¶m2=value2 HTTP/1.1</p>
    <p>Согласно стандарту HTTP, запросы типа GET считаются идемпотентными[4] &mdash; многократное повторение одного и того же запроса GET должно приводить к одинаковым результатам (при условии, что сам ресурс не изменился за время между запросами). Это позволяет кэшировать ответы на запросы GET.</p>
    <p>Кроме обычного метода GET, различают ещё условный GET и частичный GET. Условные запросы GET содержат заголовки If-Modified-Since, If-Match, If-Range и подобные. Частичные GET содержат в запросе Range. Порядок выполнения подобных запросов определён стандартами отдельно.</p></td></tr>
    <tr><td><strong>HEAD</strong></td>
    <td><p>Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.</p>
    <p>Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше копия ресурса помечается как устаревшая.</p></td></tr>
    <tr><td><strong>POST</strong></td>
    <td><p>Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами &mdash; текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы.</p>
    <p>В отличие от метода GET, метод POST не считается идемпотентным[4], то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться одна копия этого комментария).</p>
    <p>При результатах выполнения 200 (Ok) и 204 (No Content) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location.</p>
    <p>Сообщение ответа сервера на выполнение метода POST не кэшируется.</p></td></tr>
    <tr><td><strong>PUT</strong></td>
    <td><p>Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существовало ресурса, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-* передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).</p>
    <p>Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствуют находящемуся по данному URI ресурсу.</p>
    <p>Сообщения ответов сервера на метод PUT не кэшируются.</p></td></tr>
    <tr><td><strong>PATCH</strong></td>
    <td><p>Аналогично PUT, но применяется только к фрагменту ресурса.</p></td></tr>
    <tr><td><strong>DELETE</strong></td>
    <td><p>Удаляет указанный ресурс.</p></td></tr>
    <tr><td><strong>TRACE</strong></td>

    <td><p>Возвращает полученный запрос так, что клиент может увидеть, что промежуточные сервера добавляют или изменяют в запросе.</p></td></tr>
    <tr><td><strong>LINK</strong></td>
    <td><p>Устанавливает связь указанного ресурса с другими.</p></td></tr>
    <tr><td><strong>UNLINK</strong></td>
    <td><p>Убирает связь указанного ресурса с другими.</p></td></tr>
    </tbody></table>

Каждый сервер обязан поддерживать как минимум методы GET и HEAD. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус 501 (Not Implemented). Если серверу метод известен, но он не применим к конкретному ресурсу, то возвращается сообщение с кодом 405 (Method Not Allowed). В обоих случаях серверу следует включить в сообщение ответа заголовок Allow со списком поддерживаемых методов.

Наиболее востребованными являются методы GET и POST — на человеко-ориентированных ресурсах, POST — роботами поисковых машин и оффлайн-браузерами.

.. note::

    **Прокси-сервер**

    Прокси - это транзитный сервер, перенаправляющий HTTP-трафик. Прокси-серверы используются для ускорения выполнения запросов путем кэширования веб-страниц. В локальной сети применяется как межсетевой экран и средство управления HTTP-трафиком (например, для блокирования доступа к некоторым ресурсам). В Интернете прокси часто используют для анонимизации запросов - в этом случае веб-сервер получает ip-адрес прокси-сервера, а не реального клиента. В современных браузерах можно задать целый список прокси и переключаться между серверами из этого списка по мере необходимости (обычно такая возможность доступна через расширения или плагины браузера).

Коды состояния
~~~~~~~~~~~~~~

**Код состояния** информирует клиента о результатах выполнения запроса и определяет его дальнейшее поведение. Набор кодов состояния является стандартом, и все они описаны в соответствующих документах RFC.

Каждый код представляется целым трехзначным числом. Первая цифра указывает на класс состояния, последующие - порядковый номер состояния (рис 1.). За кодом ответа обычно следует краткое описание на английском языке.

.. figure:: /_static/status.gif
    :align: center

    Рис. 1. Структура кода состояния HTTP

Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.

Применяемые в настоящее время классы кодов состояния и некоторые примеры ответов сервера приведены в табл. 2.

Таблица 2. Коды состояния протокола HTTP

.. raw:: html

    <table summary="Классы кодов состояния">
    <tbody><tr><th>Класс кодов</th><th>Краткое описание</th></tr>
    <tr><td><strong>1xx Informational</strong> (Информационный)</td>
    <td><p>В этот класс выделены коды, информирующие о процессе передачи. В HTTP/1.0 сообщения с такими кодами должны игнорироваться. В HTTP/1.1 клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. <a href="#proxy">Прокси-сервера</a> подобные сообщения должны отправлять дальше от сервера к клиенту.</p>
    <p>Примеры ответов сервера:</p>
    <pre>100 Continue (Продолжать)
    101 Switching Protocols (Переключение протоколов)
    102 Processing (Идёт обработка)
    </pre>
    </td></tr>
    <tr><td><strong>2xx Success</strong> (Успешно)</td>
        <td><p>Сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса сервер может ещё передать заголовки и тело сообщения.</p>
    <p>Примеры ответов сервера:</p>
    <pre>200 OK (Успешно).
    201 Created (Создано)
    202 Accepted (Принято)
    204 No Content (Нет содержимого)
    206 Partial Content (Частичное содержимое)
    </pre>
    </td></tr>
    <tr><td><strong>3xx</strong> Redirection (Перенаправление)</td>
        <td><p>Коды статуса класса 3xx сообщают клиенту, что для успешного выполнения операции нужно произвести следующий запрос к другому URI. В большинстве случаев новый адрес указывается в поле Location заголовка. Клиент в этом случае должен, как правило, произвести автоматический переход (жарг. «редирект»).</p>
        <p>Обратите внимание, что при обращении к следующему ресурсу можно получить ответ из этого же класса кодов. Может получиться даже длинная цепочка из перенаправлений, которые, если будут производиться автоматически, создадут чрезмерную нагрузку на оборудование. Поэтому разработчики протокола HTTP настоятельно рекомендуют после второго подряд подобного ответа обязательно запрашивать подтверждение на перенаправление у пользователя (раньше рекомендовалось после 5-го). За этим следить обязан клиент, так как текущий сервер может перенаправить клиента на ресурс другого сервера. Клиент также должен предотвратить попадание в круговые перенаправления.</p>
    <p>Примеры ответов сервера:</p>
    <pre>300 Multiple Choices (Множественный выбор)
    301 Moved Permanently (Перемещено навсегда)
    304 Not Modified (Не изменялось)
    </pre>

    </td></tr>
    <tr><td><strong>4xx Client Error</strong> (Ошибка клиента)</td>
        <td><p>Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.</p>
        <p>Примеры ответов сервера:</p>
    <pre>401 Unauthorized (Неавторизован)
    402 Payment Required (Требуется оплата)
    403 Forbidden (Запрещено)
    404 Not Found (Не найдено)
    405 Method Not Allowed (Метод не поддерживается)
    406 Not Acceptable (Не приемлемо)
    407 Proxy Authentication Required (Требуется аутентификация прокси)
    </pre>

        </td></tr>
    <tr><td><strong>5xx Server Error</strong> (Ошибка сервера)</td>
        <td><p>Коды 5xx выделены под случаи неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.</p><p>Примеры ответов сервера:</p>
    <pre>500 Internal Server Error (Внутренняя ошибка сервера)
    502 Bad Gateway (Плохой шлюз)
    503 Service Unavailable (Сервис недоступен)
    504 Gateway Timeout (Шлюз не отвечает)
    </pre>
    </td></tr></tbody></table>

Заголовки HTTP
==============

**Заголовок HTTP** (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение». Формат заголовка соответствует общему формату заголовков текстовых сетевых сообщений ARPA (RFC 822). Как правило, браузер и веб-сервер включают в сообщения более чем по одному заголовку. Заголовки должны отправляться раньше тела сообщения и отделяться от него хотя бы одной пустой строкой (CRLF).

Название параметра должно состоять минимум из одного печатного символа (ASCII-коды от 33 до 126). После названия сразу должен следовать символ двоеточия. Значение может содержать любые символы ASCII, кроме перевода строки (CR, код 10) и возврата каретки (LF, код 13).

Пробельные символы в начале и конце значения обрезаются. Последовательность нескольких пробельных символов внутри значения может восприниматься как один пробел. Регистр символов в названии и значении не имеет значения (если иное не предусмотрено форматом поля).

Пример заголовков ответа сервера:

.. code-block:: bash

    Server: Apache/2.2.3 (CentOS)
    Last-Modified: Wed, 09 Feb 2011 17:13:15 GMT
    Content-Type: text/html; charset=UTF-8
    Accept-Ranges: bytes
    Date: Thu, 03 Mar 2011 04:04:36 GMT
    Content-Length: 2945
    Age: 51
    X-Cache: HIT from proxy.omgtu
    Via: 1.0 proxy.omgtu (squid/3.1.8)
    Connection: keep-alive

    200 OK

Все HTTP-заголовки разделяются на четыре основных группы:

1.  General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
2.  Request Headers (Заголовки запроса) — используются только в запросах клиента.
3.  Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
4.  Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

**Сущности** (entity, в переводах также встречается название "объект") — это полезная информация, передаваемая в запросе или ответе. Сущность состоит из метаинформации (заголовки) и непосредственно содержания (тело сообщения).

В отдельный класс заголовки сущности выделены, чтобы не путать их с заголовками запроса или заголовками ответа при передаче множественного содержимого (multipart/*). Заголовки запроса и ответа, как и основные заголовки, описывают всё сообщение в целом и размещаются только в начальном блоке заголовков, в то время как заголовки сущности характеризуют содержимое каждой части в отдельности, располагаясь непосредственно перед её телом.

В таблице 3 приведено краткое описание некоторых HTTP-заголовков.

Таблица 3. Заголовки HTTP

.. raw:: html

    <table summary="Заголовки HTTP">
    <thead><tr><th>Заголовок</th><th>Группа</th><th>Краткое описание</th></tr></thead>
        <tbody>
            <tr>
                <td>Allow</td>
                <td>Entity</td>
                <td>Список методов, применимых к запрашиваемому ресурсу.</td>
            </tr>
            <tr>
                <td>Content-Encoding</td>
                <td>Entity</td>
                <td>Применяется при необходимости перекодировки содержимого (например, gzip/deflated).</td>
            </tr>
            <tr>
                <td>Content-Language</td>
                <td>Entity</td>
                <td>Локализация содержимого (язык(и)) </td>
            </tr>
            <tr>
                <td>Content-Length</td>
                <td>Entity</td>
                <td>Размер тела сообщения (в октетах)</td>
            </tr>
            <tr>
                <td>Content-Range</td>
                <td>Entity</td>
                <td>Диапазон (используется для поддержания многопоточной загрузки или дозагрузки)</td>
            </tr>
            <tr>
                <td>Content-Type</td>
                <td>Entity</td>
                <td>Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset)</td>
            </tr>
            <tr>
                <td>Expires</td>
                <td>Entity</td>
                <td>Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами </td>
            </tr>
            <tr>
                <td>Last-Modified</td>
                <td>Entity</td>
                <td>Дата/время последней модификации сущности</td>
            </tr>
            <tr>
                <td>Cache-Control</td>
                <td>General</td>
                <td>Определяет директивы управления механизмами кэширования. Для прокси-серверов.</td>
            </tr>
            <tr>
                <td>Connection</td>
                <td>General</td>
                <td>Задает параметры, требуемые для конкретного соединения.</td>
            </tr>
            <tr>
                <td>Date</td>
                <td>General</td>
                <td>Дата и время формирования сообщения</td>
            </tr>
            <tr>
                <td>Pragma</td>
                <td>General</td>
                <td>Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache). </td>
            </tr>
            <tr>
                <td>Transfer-Encoding</td>
                <td>General</td>
                <td>Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность. </td>
            </tr>
            <tr>
                <td>Via</td>
                <td>General</td>
                <td>Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером. </td>
            </tr>
            <tr>
                <td>Warning</td>
                <td>General</td>
                <td>Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении.</td>
            </tr>
            <tr>
                <td>Accept</td>
                <td>Request</td>
                <td>Определяет применимые типы данных, ожидаемых в ответе.</td>
            </tr>
            <tr>
                <td>Accept-Charset</td>
                <td>Request</td>
                <td>Определяет кодировку символов (charset) для данных, ожидаемых в ответе. </td>
            </tr>
            <tr>
                <td>Accept-Encoding</td>
                <td>Request</td>
                <td>Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip) </td>
            </tr>
            <tr>
                <td>Accept-Language</td>
                <td>Request</td>
                <td>Применимые языки. Используется для согласования передачи.</td>
            </tr>
            <tr>
                <td>Authorization</td>
                <td>Request</td>
                <td>Учетные данные клиента, запрашивающего ресурс.</td>
            </tr>
            <tr>
                <td>From</td>
                <td>Request</td>
                <td>Электронный адрес отправителя</td>
            </tr>
            <tr>
                <td>Host</td>
                <td>Request</td>
                <td>Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80.</td>
            </tr>
            <tr>
                <td>If-Modified-Since</td>
                <td>Request</td>
                <td>Используется для выполнения <acronym title="">условных методов</acronym> (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша.</td>
            </tr>
            <tr>
                <td>Max-Forwards</td>
                <td>Request</td>
                <td>Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS. </td>
            </tr>
            <tr>
                <td>Proxy-Authorization</td>
                <td>Request</td>
                <td>Используется при запросах, проходящих через прокси, требующие авторизации</td>
            </tr>
            <tr>
                <td>Referer</td>
                <td>Request</td>
                <td>Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта. </td>
            </tr>
            <tr>
                <td>User-Agent</td>
                <td>Request</td>
                <td>Информация о пользовательском агенте (клиенте)</td>
            </tr>
            <tr>
                <td>Location</td>
                <td>Response</td>
                <td>Адрес перенаправления</td>
            </tr>
            <tr>
                <td>Proxy-Authenticate</td>
                <td>Response</td>
                <td>Сообщение о статусе с кодом 407.</td>
            </tr>
            <tr>
                <td>Server</td>
                <td>Response</td>
                <td>Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер).</td>
            </tr>
        </tbody>
    </table>


В листинге 1 приведен фрагмент дампа заголовков при подключении к серверу http://example.org

Листинг 1. Заголовки HTTP

.. code-block:: bash

    http://www.example.org/

    GET http://www.example.org/ HTTP/1.1
    Host: www.example.org
    User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9.2.13) Gecko/20101203 SUSE/3.6.13-0.2.1 Firefox/3.6.13
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: ru-ru,ru;q=0.8,en-us;q=0.5,en;q=0.3
    Accept-Encoding: gzip,deflate
    Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.7
    Keep-Alive: 115
    Proxy-Connection: keep-alive

    HTTP/1.0 302 Moved Temporarily
    Date: Thu, 03 Mar 2011 06:48:28 GMT
    Location: http://www.iana.org/domains/example/
    Server: BigIP
    Content-Length: 0
    X-Cache: MISS from proxy.omgtu
    Via: 1.0 proxy.omgtu (squid/3.1.8)
    Connection: keep-alive
    ----------------------------------------------------------
    http://www.iana.org/domains/example/

    GET http://www.iana.org/domains/example/ HTTP/1.1
    Host: www.iana.org
    User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9.2.13) Gecko/20101203 SUSE/3.6.13-0.2.1 Firefox/3.6.13
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
    Accept-Language: ru-ru,ru;q=0.8,en-us;q=0.5,en;q=0.3
    Accept-Encoding: gzip,deflate
    Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.7
    Keep-Alive: 115
    Proxy-Connection: keep-alive

    HTTP/1.0 200 OK
    Server: Apache/2.2.3 (CentOS)
    Last-Modified: Wed, 09 Feb 2011 17:13:15 GMT
    Content-Type: text/html; charset=UTF-8
    Accept-Ranges: bytes
    Date: Thu, 03 Mar 2011 04:04:36 GMT
    Content-Length: 2945
    Age: 9858
    X-Cache: HIT from proxy.omgtu
    Via: 1.0 proxy.omgtu (squid/3.1.8)
    Connection: keep-alive

    ....

Несколько полезных примеров php-скриптов, обрабатывающих HTTP-заголовки, приведены в статье «Использование файла .htaccess» (редирект, отправка кода ошибки, установка last-modified и т.п.).

Тело сообщения
==============

Тело HTTP сообщения (message-body), если оно присутствует, используется для передачи сущности, связанной с запросом или ответом. Тело сообщения (message-body) отличается от тела сущности (entity-body) только в том случае, когда при передаче применяется кодирование, указанное в заголовке Transfer-Encoding. В остальных случаях тело сообщения идентично телу сущности.

Заголовок Transfer-Encoding должен отправляться для указания любого кодирования передачи, примененного приложением в целях гарантирования безопасной и правильной передачи сообщения. Transfer-Encoding - это свойство сообщения, а не сущности, и оно может быть добавлено или удалено любым приложением в цепочке запросов/ответов.

Присутствие тела сообщения в запросе отмечается добавлением к заголовкам запроса поля заголовка Content-Length или Transfer-Encoding. Тело сообщения (message-body) может быть добавлено в запрос только когда метод запроса допускает тело объекта (entity-body).

Все ответы содержат тело сообщения, возможно нулевой длины, кроме ответов на запрос методом HEAD и ответов с кодами статуса 1xx (Информационные), 204 (Нет содержимого, No Content), и 304 (Не модифицирован, Not Modified).

Контрольные вопросы
===================

1. В каком случае клиент получит от сервера ответ с кодом 418?
